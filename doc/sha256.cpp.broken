///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//		     SHA-256 As defined by NIST.FIPS.180-4                   //
//                     A great visualizer can be found at                    //
//                                                                           //
//                        https://sha256algorithm.com                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <array>
#include <vector>
#include <string>
#include <iostream>

using namespace std;

typedef uint32_t Word;
typedef array<Word, 64> SHA256_Constants;
typedef array<Word, 8> Digest;
typedef vector<unsigned char> Message;
typedef array<Word, 16> Block;
typedef array<Word, 64> Schedule;


// Section 4.4.2 SHA-256 Constants
//
// These words represent the first thirty-two bits of the fractional parts of
// the cube roots of the first sixty-four prime numbers. In hex, these constant
// words are (from left to right)

SHA256_Constants K = {
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,
    0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,
    0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,
    0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,
    0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,
    0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,
    0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,
    0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,
    0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2};

// Section 5.3.3 SHA-256
//
// For SHA-256, the initial hash value, H(0), shall consist of the following 
// eight 32-bit words, in hex. These words were obtained by taking the first
// thirty-two bits of the fractional parts of the square roots of the first
// eight prime numbers.

Digest H0 = {
    0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,
    0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19};

// Section 4.1.2 SHA-256 Functions
//
// SHA-256 uses six logical functions, where each function operates on 32-bit
// words which are represented as x, y, and z, The result of each function is
// a new 32 bit word.
//
// Ch and Maj are apperently for Choose and Major, respectively.
// https://crypto.stackexchange.com/questions/5358/what-does-maj-and-ch-mean-in-sha-256-algorithm

inline Word Ch(Word x, Word y, Word z) {return (x&y)^((~x)&z);}         // 4.2
inline Word Maj(Word x, Word y, Word z) {return (x&y)^(x&z)^(y&z);}     // 4.3
inline Word ROTR(int n, Word x) {return (x>>n)|(x<<(32-n));}  // 3.2.4
inline Word SHR(int n, Word x) {return (x>>n);}                         // 3.2.3

inline Word SIGMA0(Word x) {return ROTR(2,x) ^ ROTR(13,x) ^ ROTR(22,x);} // 4.4
inline Word SIGMA1(Word x) {return ROTR(6,x) ^ ROTR(11,x) ^ ROTR(25,x);} // 4.5
inline Word sigma0(Word x) {return ROTR(7,x) ^ ROTR(18,x) ^ SHR(3,x);}   // 4.6
inline Word sigma1(Word x) {return ROTR(17,x) ^ ROTR(19,x) ^ SHR(10,x);} // 4.7

// 5.1 Padding The Message
// The purpose of this padding is to ensure that the padded message is a multiple
// of 512 bits. Padding can be inserted before hash computation begins on a
// message, or at any other time during the hash computation prior to processing
// the block(s) that will contain the padding.

static Message pad(uint64_t l) {
    Message padding = {0x80};
    int k = (448 - (l%512 + 1) - 7) / 8; // zero filled bytes to add
    padding.resize(k+1, 0);
    
    union {
        uint64_t m;
        unsigned char b[8];
    } bad_wolf;
    
    bad_wolf.m = l;
    // reverse byte order for little endian machines like x86 and Apple Si
    for (int i = 7; i > -1; i--) padding.push_back(bad_wolf.b[i]);
    
    return padding;
}

// 6.2.2 SHA-256 Hash Computation
// Prepare the message schedule

Schedule schedule(const Block& M) {
    Schedule W;
    int t = 0;
    
    do {
        W[t] = M[t];
        t++;
    } while(t < 16);
    do {
        W[t] = sigma1(W[t-2]) + W[t-7] + sigma0(W[t-15]) + W[t-16];
        t++;
    } while (t < 64);
    
    return W;
}

Digest runschedule(const Schedule& W, const Digest& H) {
    Digest q = H;
    Word a = q[0], b = q[1], c = q[2], d = q[3],
    e = q[4], f = q[5], g = q[6], h = q[7];
    
    for (int t = 0; t < 64; t++) {
        Word T1 = h + SIGMA1(e) + Ch(e,f,g) + K[t] + W[t];
        Word T2 = SIGMA0(a) + Maj(a,b,c);
        h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
    }
    
    q[0] = a + q[0];
    q[1] = b + q[1];
    q[2] = c + q[2];
    q[3] = d + q[3];
    q[4] = e + q[4];
    q[5] = f + q[5];
    q[6] = g + q[6];
    q[7] = f + q[7];
    
    return q;
}

Digest message(const Message& msg, const Digest& digest) {
    uint64_t  messagelength = msg.size() * 8;
    Digest newdigest;
    Message padding = {};
    Message m = msg;
    
    padding = pad(messagelength);
    
    for (auto e : padding) m.push_back(e);
    
    cout << "Message Length in bits: " << messagelength << "\n";
    cout << "Padded Length in bits: " << m.size() * 8 << "\n";
    
    // Parse the message 64 bytes at a time and process each block
    int i = 0, j = 0;
    do {
        Block B;
        unsigned char a,b,c,d;
        Word w = 0;
        
        do {
            a = m[i++]; b = m[i++]; c = m[i++]; d = m[i++];
            w = w | a; w <<= 8;
            w = w | b; w <<= 8;
            w = w | c; w <<= 8;
            w = w | d;
            B[j++] = w;
        } while (j < B.size());
        
        Schedule s = schedule(B);
        newdigest = runschedule(s, digest);
    } while (i < m.size());
    
    return newdigest;
}

Word reverseByteOrder(Word w) {
    array<unsigned char, 4> bytes;
    const Word mask = 0x000000ff;
    bytes[0] = w & mask;
    bytes[1] = (w >> 8) & mask;
    bytes[2] = (w >> 16) & mask;
    bytes[3] = (w >> 24) & mask;
    for (auto b : bytes) {w |= b; w <<= 8;}
    return w;
}

SHA256_Constants reversedWords64(const SHA256_Constants& wa) {
    SHA256_Constants wl;
    int i = 0;
    for (auto w : wa) {wl[i] = reverseByteOrder(w); i++;}
    return wl;
}

string wordToHexString(Word w) {
    const char lut[] = "0123456789abcdef";
    const Digest nibbles = {0xf0000000,0x0f000000,0x00f00000,0x000f0000,
        0x0000f000,0x00000f00,0x000000f0,0x0000000f};
    const char shifts[] = {28,24,20,16,12,8,4,0};
    string hex = "";
    
    for (char j = 0; j < 8; j++) {
        Word nibble = w & nibbles[j];
        nibble >>= shifts[j];
        hex += lut[nibble];
    }
    
    return string("0x") + hex;
}

string getDigestAsHex(const Digest& digest) {
    const char lut[] = "0123456789abcdef";
    const Digest nibbles = {0xf0000000,0x0f000000,0x00f00000,0x000f0000,
        0x0000f000,0x00000f00,0x000000f0,0x0000000f};
    const char shifts[] = {28,24,20,16,12,8,4,0};
    string hex = "";
    
    for (auto w : digest) {
        for (char j = 0; j < 8; j++) {
            Word nibble = w & nibbles[j];
            nibble >>= shifts[j];
            hex += lut[nibble];
        }
    }
    
    return hex;
}

string getDigestAsBin(const Digest& digest) {
    string bits = "";
    
    for (auto w : digest) {
        for (char j = 0; j < 32; j++) {
            Word x = w & 0x80000000;
            bits += x ? "1" : "0";
            w <<= 1;
        }
    }
    
    return bits;
}

int main() {
    Message msg = {97, 98, 99}; // "abc"
    Digest digest = H0;
    
    digest = message(msg,digest);
    cout << "Digest = " << getDigestAsHex(digest) << "\n";
    cout << "Binary = " << getDigestAsBin(digest) << "\n";
    
    return 0;
}

